fn main() {
    // println!("Problem 1: {}", problem1());
    // println!("Problem 2: {}", problem2());
    // println!("Problem 3: {}", problem3());
    // println!("Problem 4: {}", problem4());
    // println!("Problem 5: {}", problem5());
    // println!("Problem 6: {}", problem6());
    // println!("Problem 7: {}", problem7());
    // println!("Problem 8: {}", problem8());
    println!("Problem 9: {}", problem9());
}

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
fn problem1() -> i64 {
    let multiples = vec![3, 5];
    return sum_multiples_below_number(1000, &multiples);
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
fn problem2() -> i64 {
    return sum_fib_sequence_below_number_and_divisible_by(4000000, 2)
}

// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?
fn problem3() -> i64 {
    return get_largest_prime_factor(600851475143);
}

// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
fn problem4() -> i64 {
    return get_largest_palindrome(3);
}

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
fn problem5() -> i64 {
    let mut current = 1;
    loop {
        let mut has_remainder = false;
        for n in 1..20 {
            if (current % n) != 0 {
                has_remainder = true;
                break;
            }
        }
        if !has_remainder {
            return current;
        }
        current = current + 1;
    }
}

// The sum of the squares of the first ten natural numbers is,
// 1^2+2^2+...+10^2=385
// The square of the sum of the first ten natural numbers is,
// (1+2+...+10)^2=55^2=3025
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025−385=2640.
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
fn problem6() -> i64 {
    let _count = 100;
    return square_of_sum(_count) - sum_of_squares(_count);
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number?
fn problem7() -> i64 {
    return get_nth_prime_number(10001);
}

// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
fn problem8() -> i64 {
    let digits = "73167176531330624919225119674426574742355349194934\
    96983520312774506326239578318016984801869478851843\
    85861560789112949495459501737958331952853208805511\
    12540698747158523863050715693290963295227443043557\
    66896648950445244523161731856403098711121722383113\
    62229893423380308135336276614282806444486645238749\
    30358907296290491560440772390713810515859307960866\
    70172427121883998797908792274921901699720888093776\
    65727333001053367881220235421809751254540594752243\
    52584907711670556013604839586446706324415722155397\
    53697817977846174064955149290862569321978468622482\
    83972241375657056057490261407972968652414535100474\
    82166370484403199890008895243450658541227588666881\
    16427171479924442928230863465674813919123162824586\
    17866458359124566529476545682848912883142607690042\
    24219022671055626321111109370544217506941658960408\
    07198403850962455444362981230987879927244284909188\
    84580156166097919133875499200524063689912560717606\
    05886116467109405077541002256983155200055935729725\
    71636269561882670428252483600823257530420752963450";
    return get_largest_adjacent_product(digits, 13);
}

// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
//
// a^2 + b^2 = c^2
// For example, (3^2 + 4^2) = (9 + 16) = 25 = 5^2.
//
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
fn problem9() -> i64 {
    for b in 0..999 {
        for a in 0..b {
            let c = ((a + b) as f64).sqrt();
            // println!("{} + {} + {} = {}", a, b, c, 1000);
            if (a + b + c as i32) == 1000 {
                println!("{} + {} = {}, product = {}", a, b, c, a * b * c as i32);
            }
        }
    }
    return 0;
}

fn get_largest_adjacent_product(string: &str, num_adjacent: usize) -> i64 {
    let chars = string.chars();
    let bytes = string.as_bytes();
    let mut greatest: i64 = 0;
    let length = string.len();
    for i in 0..(length - num_adjacent) {
        let mut numbers: Vec<i64> = vec![];
        for j in 0..num_adjacent {
            let c = bytes[i + j] as char;
            let d = c.to_digit(10).unwrap();
            numbers.push(d as i64);
        }
        let product: i64 = numbers.iter().product();
        if product > greatest {
            greatest = product;
        }
    }
    return greatest;
}

fn get_nth_prime_number(n: i64) -> i64 {
    let mut index = 0;
    let mut number = 2;
    while index != n {
        if is_prime(number) {
            index = index + 1;
        }
        number = number + 1;
    }
    return number;
}

fn sum_of_squares(count: i64) -> i64 {
    let mut sum = 0;
    for n in 1..=count {
        sum += n.pow(2);
    }
    return sum;
}

fn square_of_sum(count: i64) -> i64 {
    let mut sum = 0;
    for n in 1..=count {
        sum += n;
    }
    return sum.pow(2);
}

fn get_largest_palindrome(number_of_digits: u32) -> i64 {
    let mut largest = 0;
    let base: i64 = 10;
    let max = base.pow(number_of_digits);
    for n1 in 0..max {
        for n2 in 0..max {
            let product = n1 * n2;
            if is_palindromic(product) {
                if product > largest {
                    largest = product;
                }
            }
        }
    }
    return largest;
}

fn is_palindromic(number: i64) -> bool {
    let s: String = number.to_string();
    let sb = s.as_bytes();
    let length = s.len();
    let half = length / 2;
    if s.len() < 2 {
        return true;
    }
    for i in 0..(half + 1) {
        if sb[i] != sb[length - 1 - i] {
            return false;
        }
    }
    return true;
}


fn get_largest_prime_factor(number: i64) -> i64 {
    let max = number / 2;
    let mut largest = 0;
    for n in 1..max {
        if is_prime(n) {
            if max % n == 0 {
                largest = n;
            }
        }
    }
    return largest;
}

fn is_prime(number: i64) -> bool {
    let max_divisor = (number as f64).sqrt() as i64;
    for n2 in 2..=max_divisor {
        if number % n2 == 0 {
            return false;
        }
    }
    return true;
}

fn sum_fib_sequence_below_number_and_divisible_by(number: i64, divisible_by: i64) -> i64 {
    let mut term1 = 1;
    let mut term2 = 2;
    let mut temp = term1 + term2;
    let mut sum = term1 + term2;
    while temp < number {
        temp = term1 + term2;
        if temp % divisible_by == 0 {
            sum += temp;
        }
        term1 = term2;
        term2 = temp;
    }
    return sum;
}

fn sum_multiples_below_number(number: i64, multiples_of: &Vec<i64>) -> i64 {
    let mut sum = 0;
    for n in 1..number {
        let mut is_multiple = false;
        for multiple_of in multiples_of {
            if (n % multiple_of) == 0 {
                is_multiple = true;
            }
        }
        if is_multiple {
            sum = sum + n;
        }
    }
    return sum;
}
