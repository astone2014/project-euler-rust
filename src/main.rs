fn main() {
    // println!("Problem 1: {}", problem1());
    // println!("Problem 2: {}", problem2());
    // println!("Problem 3: {}", problem3());
    // println!("Problem 4: {}", problem4());
    // println!("Problem 5: {}", problem5());
    // println!("Problem 6: {}", problem6());
    // println!("Problem 7: {}", problem7());
    // println!("Problem 8: {}", problem8());
    // println!("Problem 9: {}", problem9()); NOT SOLVED
    // println!("Problem 10: {}", problem10());
    println!("Problem 11: {}", problem11());
}

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
fn problem1() -> i64 {
    let multiples = vec![3, 5];
    return sum_multiples_below_number(1000, &multiples);
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
fn problem2() -> i64 {
    return sum_fib_sequence_below_number_and_divisible_by(4000000, 2);
}

// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?
fn problem3() -> i64 {
    return get_largest_prime_factor(600851475143);
}

// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
fn problem4() -> i64 {
    return get_largest_palindrome(3);
}

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
fn problem5() -> i64 {
    let mut current = 1;
    loop {
        let mut has_remainder = false;
        for n in 1..20 {
            if (current % n) != 0 {
                has_remainder = true;
                break;
            }
        }
        if !has_remainder {
            return current;
        }
        current = current + 1;
    }
}

// The sum of the squares of the first ten natural numbers is,
// 1^2+2^2+...+10^2=385
// The square of the sum of the first ten natural numbers is,
// (1+2+...+10)^2=55^2=3025
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025−385=2640.
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
fn problem6() -> i64 {
    let _count = 100;
    return square_of_sum(_count) - sum_of_squares(_count);
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number?
fn problem7() -> i64 {
    return get_nth_prime_number(10001);
}

// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
fn problem8() -> i64 {
    let digits = "73167176531330624919225119674426574742355349194934\
    96983520312774506326239578318016984801869478851843\
    85861560789112949495459501737958331952853208805511\
    12540698747158523863050715693290963295227443043557\
    66896648950445244523161731856403098711121722383113\
    62229893423380308135336276614282806444486645238749\
    30358907296290491560440772390713810515859307960866\
    70172427121883998797908792274921901699720888093776\
    65727333001053367881220235421809751254540594752243\
    52584907711670556013604839586446706324415722155397\
    53697817977846174064955149290862569321978468622482\
    83972241375657056057490261407972968652414535100474\
    82166370484403199890008895243450658541227588666881\
    16427171479924442928230863465674813919123162824586\
    17866458359124566529476545682848912883142607690042\
    24219022671055626321111109370544217506941658960408\
    07198403850962455444362981230987879927244284909188\
    84580156166097919133875499200524063689912560717606\
    05886116467109405077541002256983155200055935729725\
    71636269561882670428252483600823257530420752963450";
    return get_largest_adjacent_product(digits, 13);
}

// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
//
// a^2 + b^2 = c^2
// For example, (3^2 + 4^2) = (9 + 16) = 25 = 5^2.
//
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
fn problem9() -> i64 {
    for b in 0..999 {
        for a in 0..b {
            let c = ((a + b) as f64).sqrt();
            // println!("{} + {} + {} = {}", a, b, c, 1000);
            if (a + b + c as i32) == 1000 {
                println!("{} + {} = {}, product = {}", a, b, c, a * b * c as i32);
            }
        }
    }
    return 0;
}

// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
// Find the sum of all the primes below two million.
fn problem10() -> i64 {
    let mut sum = 0;
    let below = 2000000;
    for n in 2..below {
        if is_prime(n) {
            sum += n;
        }
    }
    return sum;
}

// In the 20×20 grid below, four numbers along a diagonal line have been marked in red.

// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.

// What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
fn problem11() -> i64 {
    let string = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";
    let digits: Vec<Vec<i64>> = vec![];
    let bytes = string.as_bytes();
    let chars = string.chars();
    let length = string.len();
    let mut i = 0;
    while i < length {
        let c = bytes[i] as char;
        if c != ' ' && c != '\n' && c != '\r' {
            println!("{}{}", bytes[i] as char, bytes[i + 1] as char);
            i += 2;
            continue;
        } else {
            println!("something else '{}'", c);
        }
        i += 1;
    }
    return 0;
}

fn get_largest_adjacent_product(string: &str, num_adjacent: usize) -> i64 {
    let chars = string.chars();
    let bytes = string.as_bytes();
    let mut greatest: i64 = 0;
    let length = string.len();
    for i in 0..(length - num_adjacent) {
        let mut numbers: Vec<i64> = vec![];
        for j in 0..num_adjacent {
            let c = bytes[i + j] as char;
            let d = c.to_digit(10).unwrap();
            numbers.push(d as i64);
        }
        let product: i64 = numbers.iter().product();
        if product > greatest {
            greatest = product;
        }
    }
    return greatest;
}

fn get_nth_prime_number(n: i64) -> i64 {
    let mut index = 0;
    let mut number = 2;
    while index != n {
        if is_prime(number) {
            index = index + 1;
        }
        number = number + 1;
    }
    return number;
}

fn sum_of_squares(count: i64) -> i64 {
    let mut sum = 0;
    for n in 1..=count {
        sum += n.pow(2);
    }
    return sum;
}

fn square_of_sum(count: i64) -> i64 {
    let mut sum = 0;
    for n in 1..=count {
        sum += n;
    }
    return sum.pow(2);
}

fn get_largest_palindrome(number_of_digits: u32) -> i64 {
    let mut largest = 0;
    let base: i64 = 10;
    let max = base.pow(number_of_digits);
    for n1 in 0..max {
        for n2 in 0..max {
            let product = n1 * n2;
            if is_palindromic(product) {
                if product > largest {
                    largest = product;
                }
            }
        }
    }
    return largest;
}

fn is_palindromic(number: i64) -> bool {
    let s: String = number.to_string();
    let sb = s.as_bytes();
    let length = s.len();
    let half = length / 2;
    if s.len() < 2 {
        return true;
    }
    for i in 0..(half + 1) {
        if sb[i] != sb[length - 1 - i] {
            return false;
        }
    }
    return true;
}

fn get_largest_prime_factor(number: i64) -> i64 {
    let max = number / 2;
    let mut largest = 0;
    for n in 1..max {
        if is_prime(n) {
            if max % n == 0 {
                largest = n;
            }
        }
    }
    return largest;
}

fn is_prime(number: i64) -> bool {
    let max_divisor = (number as f64).sqrt() as i64;
    for n2 in 2..=max_divisor {
        if number % n2 == 0 {
            return false;
        }
    }
    return true;
}

fn sum_fib_sequence_below_number_and_divisible_by(number: i64, divisible_by: i64) -> i64 {
    let mut term1 = 1;
    let mut term2 = 2;
    let mut temp = term1 + term2;
    let mut sum = term1 + term2;
    while temp < number {
        temp = term1 + term2;
        if temp % divisible_by == 0 {
            sum += temp;
        }
        term1 = term2;
        term2 = temp;
    }
    return sum;
}

fn sum_multiples_below_number(number: i64, multiples_of: &Vec<i64>) -> i64 {
    let mut sum = 0;
    for n in 1..number {
        let mut is_multiple = false;
        for multiple_of in multiples_of {
            if (n % multiple_of) == 0 {
                is_multiple = true;
            }
        }
        if is_multiple {
            sum = sum + n;
        }
    }
    return sum;
}
